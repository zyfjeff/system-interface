#include <stdio.h>

/*
 *  进程或者命令的退出码不应该大于128，因为当进程因为信号而退出，其退出码为128+信号值的和
 *  为了避免和正常退出码想混合，应该将退出码子设置在128以下。
 *
 *  exit()会执行的动作如下:
 *  1.调用退出处理程序(通过atexit和on_exit注册的函数,其执行顺序与注册顺序相反)
 *  2.刷新stdio流缓冲区
 *  3.使用由status提供的值，执行_exit系统调用
 *
 *  C99标准要求，执行到main函数结尾处的情况应等同于调用exit(0) gcc -std=c99
 *
 *  无论进程是否正常终止，下面的动作都会发生:
 *  1.关闭所有打开的文件描述符，目录流，信息目录描述符，字符集转换描述符
 *  2.作为文件描述符关闭的后果之一，将释放进程所持有的任何文件锁
 *  3.分离任何已连接的system V共享内存段，且对应与各段的shm_nattch计数器值将减1
 *  4.进程为每个system v信号量设置的semadj值将会被加到信号量值中
 *  5.如果该进程是一个管理终端的管理进程，那么系统会向该终端前台进程组中每个进程发送SIGHUP信号，接着终端会与会话脱离
 *  6.将关闭该进程打开的任何POSIX有名信号量，类似于调用sem_close()
 *  7.将关闭该进程打开的任何POSIX消息队列，类似于调用mq_close
 *  8.作为进程退出的后果之一，如果其进程组成为孤儿，且该组中存在任何已停止的进程，则组中所有进程都收到SIGHUB，随之为SIGCONT
 *  9.移除进程通过mlock或mlcokall所建立的任何内存锁
 *  10.取消该进程调用mmap所创建的任何内存映射
 *
 *  对于不在上述动作之中的资源清理动作，需要自己注册退出处理程序:
 *  注册的退出处理程序会在进程调用exit正常终止的时候自动执行，如果程序直接调用_exit或因为信号而异常终止则不会调用退出处理程序
 *
 *  atexit 注册退出处理程序 注册多个退出处理程序的时候，其中有任一退出处理程序无法返回时，后续的操作将不再执行
 *  fork创建的子进程会继承父进程注册的退出处理函数，而进程调用exec时，会移除所有已经注册的退出处理程序
 *
 *  atexit注册的退出处理程序，无法得到传递给exit的状态。也无法给退出处理程序指定参数。
 *  glibc 提供了一个非标准的替代方法: on_exit，可以传递参数,接收exit的状态
 *
 *  fork复制进程的时候会同时复制其缓冲区，当标准输出定向到终端的时候，缺省是行缓冲，当标准输出重定向到文件时
 *  缺省是块缓冲
 *
 *
 *
 */
