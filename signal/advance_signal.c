#include <signal.h>
#include <stdio.h>


/*
 *  /proc/sys/fs/suid_dumpable  针对set-user-ID和set-group-ID进程是否产生核心存储文件
 *  /proc/PID/coredump_filtera  写入核心转储文件的内存映射类型
 *  /proc/sys/kernel/core_pattern   该文件所包含的格式化字符串来控制对系统上生成的所有核心转储文件的命名
 *  core_pattern支持下列文件说明符:
 *      %c  对核心文件大小的资源软限制
 *      %e  可执行文件名
 *      %g  遭转储进程的实际组ID
 *      %h  主机系统的名称
 *      %p  遭转储进程的进程ID
 *      %s  导致进程终止的信号编号
 *      %t  转储时间
 *      %u  遭转储进程的实际用户ID
 *      %%  单个%字符
 *  TASK_UNINTERRUPTIABLE  进程正在等待某些特定类型的事件，比如磁盘IO的完成，如果为这种状态下的进程产生一个信号
 *  ，那么进程摆脱这种状态之前系统不会把信号传递给进程。极少数情况下TASK_UNINTERRUPTIABLE状态还会让系统挂起，此时
 *  SIGKILL将不会终止挂起的进程，如果问题无法得到解决，那么就只能通过重启系统来消灭该进程了。
 *  为了Linux引入了TASK_KILLABLE 该状态类似于TASK_UNINTERRUPTIABLE，但是会在进程收到致命信号的时候将其唤醒，这个时候
 *  就可以接收到信号，然后被杀死了。
 *
 *  正确处理硬件产生的信号:
 *      1.接收信号的默认行为
 *      2.为其信号编写不会正常返回的处理器函数
 *
 *  1.同步信号  使用raise kill发送信号 硬件异常产生的信号
 *  2.异步信号
 *  同步信号会立即传递，异步产生的信号，从产生到实际传递之间仍可能会存在一个瞬时延迟。
 *
 *  当多个信号被阻塞的时候，某一刻信号被解除阻塞了，那么被阻塞的信号会按照信号编号从小到大依次传递。
 *
 *  sigaction是简历信号处理器的首选API
 *  实时信号:
 *      1.实时信号的信号范围有所扩大
 *      2.实时信号采取队列化管理
 *      3.实时信号可指定伴随的数据
 *      4.不同实时信号的传递顺序得到保障
 *
 *  实时信号范围: SIGRTMIN~SIGRTMAX
 *  实时信号队列的数量限制:
 *      _POSIX_SIGQUEUE_MAX
 *
 *  使用sigqueue来发送实时信号，一旦排队的信号达到了限制的数量，sigqueue将会失败，并设置errno为EAGAIN
 *  #include <signal.h>
 *  int sigqueue(pid_t pid, int sig, const union sigval value);
 *
 * 信号编程的时候，可能会偶尔出现如下情况:
 *  1.临时阻塞一个信号，防止其信号处理器不会将某些关键代码片段的执行中断
 *  2.解除对信号的阻塞，然后暂停执行，直到有信号到达。
 *
 *  错误做法:
 *      屏蔽指定信号
 *      执行关键操作
 *      解除屏蔽信号
 *                      <----　信号的产生如果发生在这里，会导致pause永久阻塞，直到第二个信号出现
 *      pause等待信号
 *
 *      为此需要将解除屏蔽信号和pause信号原子化
 *      sigsuspend就是做了上面两件事
 *      第一就是设置信号掩码
 *      第二就是挂起进程执行直到捕获到信号，
 *      第三就是恢复老的信号掩码
 *
 *  sigwaitinfo 用于同步接收信号，需要将同步的信号阻塞，到被阻塞的信号达到 sigwaitinfo返回
 *  signalfd 统一事件源，可以将信号纳入fd的统一管理范畴中
 *
 *  信号编程即繁琐也难:
 *  1.信号的异步本质就意味着需要面对各种问题，包括可重性需求，竞态条件，还有信号处理器中正确处理全局变量
 *  2.没有对标准信号进行排队处理，即使是对实时信号，也存在对信号排队数量的限制。
 *  信号所携带的信息量是有限的
 *
 *  如果用sigwaitinfo或者signalfd来同步获取到的信号，这些问题中的大部分都不会遇到
 *
 *
 */


int main()
{

}
