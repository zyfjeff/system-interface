#include <stdio.h>

/*
 *  进程组是一组相关的进程的集合　和术语作业作为同义词看待
 *  会话是一组相关的进程组的集合
 *
 *  进程组和会话是为了支持shell作业控制而定义的抽象概念
 *
 *  进程组:
 *      所有进程拥有相同的PGID，其中一个进程的PID == PGID 是进程组的组长进程
 *
 *  会话:
 *      会话首进程是创建会话的进程，进程ID == 会话ID
 *
 *  一个会话中的所有进程共享单个控制终端，控制终端会在会话首进程首次打开一个终端设备时简历，一个终端最多可能成为一个会话的
 *  控制终端，会话中的一个进程组会成为终端的前台进程组，其他进程组会成为后台进程组。
 *
 *  用户在控制终端中输入一个信号生成终端字符后，信号被发送到前台进程组中的所有成员
 *  当控制终端的连接建立起来后，会话首进程会成为该终端的控制进程，成为控制进程的主要标志是当断开与终端之间的连接时内核会向
 *  该进程发送一个SIGHUP信号
 *
 *  进程组的两个属性:
 *  1.在特定的进程组中，父进程能够等待任意子进程
 *  2.信号能够被发送给进程组中的所有成员
 *
 *
 *  getpgrp 获取一个进程的进程组ID
 *  setpgid 修改指定pid的进程的进程组id，如果指定0号pid进程，那么就相当于修改当前进程的进程组id
 *
 *  #include <unistd.h>
 *  int setpgid(pid_t pid, pid_t pgid);
 *  如果两个参数相同就会创建一个新的进程组，并且指定的进程会成为进程组的组长进程
 *  setpgid的限制:
 *  1.pid参数可以仅指定调用进程或其中一个子进程，违反这条规则将返回ESRCH错误
 *  2.在组之间移动进程时，调用进程，由pid指定的进程以及目标进程组必须是属于一个会话，否则会返回EPERM错误
 *  3.pid参数所指定的进程不能是会话首进程，违反将返回EPERM错误
 *  4.一个进程在其子进程已经执行了exec后就无法修改该子进程的进程组ID了，违反将返回EACCES错误
 *
 *  getsid 返回指定进程所属的会话id
 *  setsid 调用进程不是进程组的首进程，那么setsid会创建一个新会话
 *  如果调用进程是一个进程组首进程，那么setsid调用会报出EPERM错误。所以通常会让子进程去调用setsid，子进程肯定不会是进程组组长
 *  一个进程组的所有成员必须属于同一个会话
 *
 *  终端的控制进程在终端断开的时候会收到SIGHUP信号
 *
 *  控制进程终止时会发生下列事情:
 *  1.会话中的所有进程将会失去与控制终端之间的关联关系
 *  2.控制终端失去了与会话之间的关联关系，因此另一个会话首进程就能够获取该终端成为控制进程
 *  3.内核会向前台进程组的所有成员发送SIGHUP信号和SIGCONT信号，来通知他们控制终端的丢失
 *
 *      #include <stdio.h>
 *      char *ctermid(char *s);
 *
 *  返回控制终端的路径名
 *
 *  #include <unistd.h>
 *  pid_t tcgetpgrp(int fd);
 *  int tcsetpgrp(int fd, pid_t pgrp);
 *
 *  获取和修改一个终端的进程组
 *
 *  shell不会将不是它创建的进程组发送SIGHUP信号，即使这个进程组和shell属于同一个会话
 *
 *  控制终端进程关闭，或者是终端断开，会导致内核发送SIGHUP信号给前台进程组的所有进程
 *  只有前台进程组中的进程可以从控制终端读取输入,如果后台进程试图丑八怪终端中读取输入，那么就会收到一个SIGTTIN信号
 *  SIGTTIN信号的默认处理动作是停止作业
 *
 *  默认情况下后台作业是允许向控制终端输入内容的，但是如果终端设置了TOSTOP标志，那么后台作业尝试在终端上输出的时候
 *  会导致SIGTTOU信号，这个信号会导致作业的停止
 *
 */
