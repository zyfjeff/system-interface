#include <stdio.h>

/*
 *  pthreads数据类型:
 *  pthread_t               线程ID
 *  pthread_mutex_t         互斥对象
 *  pthread_mutexattr_t     互斥属性对象
 *  pthread_cond_t          条件变量
 *  pthread_condattr_t      条件变量的属性对象
 *  pthread_key_t           线程特有数据的键
 *  pthread_once_t          一次性初始化控制上下文
 *  pthread_attr_t          线程属性对象
 *
 *  SUSv3并未规定如何实现这些数据类型，可移植的程序应将其视为"不透明"数据，不能使用C语言的==去比较这些类型的变量
 *  多线程程序中每个线程都有自己的errno，多线程环境下errno是一个宏，是一个指向返回int *的函数
 *
 *  pthreads API都是返回0表示成功，返回一个正值表示失败。
 *
 *  终止线程:
 *      1.线程star函数执行return语句并返回指定值
 *      2.线程调用pthread_exit
 *      3.调用pthread_cancel取消线程
 *      4.任意线程调用exit，或者主线程执行了return语句,都会导致进程中的所有线程立即终止
 *
 *  pthread_exit函数将终止调用线程，且返回值可由另一个线程通过调用pthread_join获取　等同于线程中执行return
 *
 *  主线程指向了pthread_exit，那么其他线程将继续运行
 *
 *  pthread_t 类型的线程ID是POSIX线程库分配的线程ID，一个POSIX线程对应与内核一个内核线程，通过gettid可以得到内核线程的ID
 *  线程未分离就必须使用pthread_join来进行连接，如果未能连接，那么线程终止时就将产生僵尸线程。
 *
 *  线程之间的关系是对等的，任何线程都可以调用pthread_join来等待其他线程。
 *  pthread_deatch 线程可以自行分离，一旦线程处于分离状态，就不能再使用pthread_join来获取其状态,也无法时期重返可连接的状态
 *  其他线程exit或是主线程执行return即便遭到分离的线程也还是会受到影响。此时不管线程处于可连接状态还是已分离状态，进程的所有线程
 *  都会立即终止。
 *
 *  线程VS进程:
 *  1.线程间数据共享简单，进程间的数据共享需要更多的投入(共享内存，管道等)
 *  2.创建线程要快于创建进程，线程间的上下文切换，其消耗时间一般比进程要短
 *
 *  1.多线程编程 需要确保调用线程安全的函数，或者按照线程安全的方式来调用函数
 *  2.某个线程的bug可能危机该进程的所有线程
 *  3.每个线程都在争用宿主进程中有限的虚拟地址空间
 *  4.多线程应用处理信号，需要小心设计，作为通则，一般建议在多线程程序中，避免使用信号
 *  5.多线程应用中，所有线程必须运行同一个车光绪
 *  6.除了数据，线程还可以共享某些其他信息(例如: 文件描述符，信号处置，当前工作目录，用户ID和组ID
 *
 *  )
 *
 *
 */

int main()
{

}
